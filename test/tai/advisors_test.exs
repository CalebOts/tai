defmodule Tai.AdvisorsTest do
  use ExUnit.Case, async: true
  doctest Tai.Advisors

  defmodule TestFactory do
    def advisor_specs(group) do
      [
        {
          group.advisor,
          [
            group_id: group.id,
            advisor_id: :my_advisor,
            order_books: %{},
            config: %{}
          ]
        }
      ]
    end
  end

  defmodule TestAdvisor do
    use Tai.Advisor
    def handle_inside_quote(_, _, _, _, state), do: {:ok, state.store}
  end

  describe ".specs" do
    @product_1 struct(Tai.Venues.Product, %{})
    @products [@product_1]
    @config struct(Tai.Config,
              advisor_groups: %{
                group_a: [
                  advisor: TestAdvisor,
                  factory: TestFactory,
                  products: "*"
                ]
              }
            )

    test "returns a list of advisor specs generated by the factory" do
      assert [advisor | []] = Tai.Advisors.specs(@config, [], @products)
      assert {TestAdvisor, _} = advisor
    end

    test "can apply filters" do
      assert [advisor | []] =
               Tai.Advisors.specs(
                 @config,
                 [
                   start_on_boot: false,
                   group_id: :group_a,
                   advisor_id: :my_advisor
                 ],
                 @products
               )

      assert {TestAdvisor, _} = advisor

      assert Tai.Advisors.specs(@config, [advisor_id: :your_advisor], @products) == []
      assert Tai.Advisors.specs(@config, [start_on_boot: true], @products) == []
      assert Tai.Advisors.specs(@config, [group_id: :group_b], @products) == []
    end
  end

  test ".info returns the pid of each spec if it's running" do
    assert Tai.Advisors.info([]) == []

    spec_1 = {
      TestAdvisor,
      [group_id: :group_a, advisor_id: :advisor_a, products: [], config: %{}]
    }

    spec_2 = {
      TestAdvisor,
      [group_id: :group_a, advisor_id: :advisor_b, products: [], config: %{}]
    }

    start_supervised!(spec_1)

    assert [{^spec_1, pid_1}, {^spec_2, pid_2}] = Tai.Advisors.info([spec_1, spec_2])
    assert is_pid(pid_1)
    assert pid_2 == nil
  end

  test ".start specs that aren't already started and returns a count of new & existing" do
    assert Tai.Advisors.start([]) == {:ok, {0, 0}}

    spec_1 = {
      TestAdvisor,
      [group_id: :group_a, advisor_id: :advisor_a, products: [], config: %{}]
    }

    spec_2 = {
      TestAdvisor,
      [group_id: :group_b, advisor_id: :advisor_b, products: [], config: %{}]
    }

    spec_3 = {
      TestAdvisor,
      [group_id: :group_c, advisor_id: :advisor_b, products: [], config: %{}]
    }

    start_supervised!(Tai.AdvisorsSupervisor)
    start_supervised!(spec_1)

    assert Tai.Advisors.start([spec_1, spec_2, spec_3]) == {:ok, {2, 1}}
  end

  test ".stop terminates specs that are running and returns a count of new & existing" do
    assert Tai.Advisors.stop([]) == {:ok, {0, 0}}

    spec_1 = {
      TestAdvisor,
      [group_id: :group_a, advisor_id: :advisor_a, products: [], config: %{}]
    }

    spec_2 = {
      TestAdvisor,
      [group_id: :group_b, advisor_id: :advisor_b, products: [], config: %{}]
    }

    spec_3 = {
      TestAdvisor,
      [group_id: :group_c, advisor_id: :advisor_b, products: [], config: %{}]
    }

    start_supervised!(Tai.AdvisorsSupervisor)
    start_supervised!(spec_1)

    assert Tai.Advisors.stop([spec_1, spec_2, spec_3]) == {:ok, {1, 2}}
  end
end
